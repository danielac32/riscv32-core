    .section .text
    .globl _start

_start:
    # Configurar el puntero de pila
    la sp, _stack_top

    # Configurar el manejador de interrupciones
    la t0, trap_vector
    csrw mtvec, t0

    # Habilitar interrupciones de temporizador
    li t0, 0x80
    csrs mie, t0

    # Habilitar interrupciones globales
    li t0, 0x8
    csrs mstatus, t0

    # Llamar a main
    call main

    # Bucle infinito si main retorna
1:  j 1b

trap_vector:
    # Guardar el contexto
    addi sp, sp, -32
    sd ra, 0(sp)
    sd t0, 8(sp)
    sd t1, 16(sp)
    sd t2, 24(sp)

    # Determinar la causa de la interrupción
    csrr t0, mcause
    li t1, 0x80000007  # Interrupción de temporizador
    beq t0, t1, handle_timer_interrupt

    # Restaurar el contexto
    ld ra, 0(sp)
    ld t0, 8(sp)
    ld t1, 16(sp)
    ld t2, 24(sp)
    addi sp, sp, 32
    mret

handle_timer_interrupt:
    call handle_timer_interrupt_c

    # Restaurar el contexto
    ld ra, 0(sp)
    ld t0, 8(sp)
    ld t1, 16(sp)
    ld t2, 24(sp)
    addi sp, sp, 32
    mret

    .section .bss
    .globl _stack_top
    .comm _stack_top, 1024  # Define el tamaño de la pila






#include <stdint.h>
#include <stddef.h>

#define CLINT_BASE_ADDR 0x11000000
#define CLINT_MTIMECMP_OFFSET 0x4000
#define CLINT_MTIME_OFFSET 0xBFF8

volatile uint64_t *mtimecmp = (uint64_t *)(CLINT_BASE_ADDR + CLINT_MTIMECMP_OFFSET);
volatile uint64_t *mtime = (uint64_t *)(CLINT_BASE_ADDR + CLINT_MTIME_OFFSET);

void init_timer(uint64_t interval) {
    uint64_t current_time = *mtime;
    *mtimecmp = current_time + interval;
}

void handle_timer_interrupt_c() {
    uint64_t interval = 1000000; // Set your desired interval here
    *mtimecmp += interval;
    // Handle the timer interrupt (e.g., increment a counter, toggle an LED, etc.)
}

int main() {
    // Initialize the timer
    init_timer(1000000);

    // Main loop
    while (1) {
        // Your main code here
    }

    return 0;
}
